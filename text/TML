= TML

TML is a lightweight markup language. It is used by adding simple codes to text,
 which then can be read by a parser, and transformed into other kinds of markup
  language codes.

TML is probably not the language you want.

== Overview
=== TML, in short
++
-- TML does not try to be comprehensive for any particular output. 
It provides basic text structuring and a few ways to insert stand-alone markup tags.
-
-- TML makes no attempt to be discrete or hidden.
-
-- TML is inflexible
It can not be customised except by re-writing the parser.
-
-- TML does not try to copy other lightweight markups. 
Some markups do this, to help a user remember how to use them. After all, markup is
is a job most users will only do now and then.

Here and there, TML implementations do sometimes adopt a few marks similar to other notations.
-
-- TML has a consistent and low-weight syntax.
-
+

=== Philosophy
TML is a generic markup. It can be transformed to several other markups. It may perform unnaturally and inefficiently for some markup styles. For example, HTML markup needs explicit statements for anchors (links), because TML can not differentiate anchors from spans. And TML has no way to escape and generate HTML entities.

In general, TML syntax is aimed at generating typographical markup. So the language may stress markup in unusual ways. For example, in HHTML there is a strong support for nested group support (divs, etc). Images, however, are treated as an afterthought. Little support exists for marking up other material, such as images, and there is no support for defining tables.

TML has no support for markup at character level.

TML is written round the parser, not the end result.

TML is written as a tool, not a comprehensive solution.

=== Output
TML output is a single line of text interspaced by tags defined by the markup.
If pretty-printing is required, the output must be run through pretty-printing
formatting code.

=== Why TML?
I've added discouragement to previous paragraphs. This, you know, is because I dislike having my (or your) time wasted.

++
@ I don't markup that often --- I write naturally in TML.
@ TML syntax is narrow, so I usually know what it is. 
@ I have often written in TML when I didn't have a parser on hand.
@ TML is easy to fix using a text editor.
+
On this last point, if I've forgotten the needed layout for some purpose, I can sketch something in even if I don't have the parser to hand. Then fix it afterwards.
 
A user will not care but... TML is nested, so can't be written purely in regex.
But any language with a regex replacement method can enable TML. TML parsing can be done with no backtracking. A look back or forward of one char will make the code simple and fast. In other words, it's natural and easy to write a parser, and possible in most languages.

=== Spec
TML has an incomplete but growing spec sheet. For questions about how spaces are handled in literals, how parsing of controls may work, go there.



== The Java parser
This Java parser uses simple character stepping. Indexing arrays in Java is slow. The parser will be slow. However, I wanted a simple implementation first.

The TML Java parser is simple and flexible. It may be rewritten to work in different ways.
 
The following comments are all based on the HTML implementation of the Java parser. Please bear in mind that other markup parsers may define different codes. However, the basic ideas are the same for any TML parser.

=== Errors and reports
TML parsers always use a stack or recursion. This TML maintains a stack.
This means that TML, though slower than possible, is robust and can give some human-useful error reports.

In this parser, error reporting can not be turned off. 



== Syntax
=== Other markup
Sometimes it is handy to be able to insert other markups into a document. For TML, the results depend on the parser implementation.

For the currrent HTML parser... if TML tries to parse HTML, then inline HTML is ignored (unless the HTML happens to have inline character codes in it). Block-level HTML is paragraphed, so best to avoid it. If HTML parses TML, there is no effect --- no TML is HTML. 

Umm, that's it. Not as good as [a{https://daringfireball.net/projects/markdown/} Markdown], but mostly ok.

=== Escaping
TML has no escapes. It's a tool.

A couple of literals are available. See later.


=== Newlines and spacing
TML removes newlines. It crushes most spaces to one space.

== Marks and attributes
TML marks are a single char/codepoint followed by attributes, followed by a whitespace.

Here's the ampersand char, with some attributes. The attributes may not make sense, may not render as anything, but they are available on any mark,

#pre
?code
@#id.class{attribute url}[attribute text]
?
#

Text can come after the mark, as long as the text is separated by whitespace,

#pre
?code
@#id.class{attribute url}[attribute text] Some text...
?
#

Text can follow the mark (the newline is whitespace),


#pre
?code
@#id.class{attribute url}[attribute text]
Some text...
?
#


A control sometimes stands alone. 

#pre
?code
@ Some text...
?
#

Anyway, let's get going.


== Block level
Block-level markup means, visually, that control codes are to the left-hand side of text. The markup may be separated from the side by space, but no othert character.


=== Anonymous paragraphs
Any text without a mark before it becomes a paragraph. Paragraphs end on a newline.

=== Marked paragraphs
Some marks can introduce a paracraph, and substitute for them.

In the HTML parser,

??
'=' makes a headline
'~' makes a "dd"
':' makes a"dt"
'@' makes a one-line "li"
?


So,

#pre
?code
~ Some charms
Not this for sure.
?
#

makes,

?.result
'<dd>Some charms<\dd><p>Not this for sure.<\p>
?

TML headlines are a paragraph, which can look at the number of controls for indent Therefore, in the language of Lightweight markup, they are [a{http://www.aaronsw.com/2002/atx/} Atx-style] (no support for underline titles, like [a{http://docutils.sourceforge.net/mirror/setext.html} Setext]).

e.g.

#pre
?code
=== Some charms
?
#

makes,

?.result
<h3>Some charms<\h3>
?

Let's fool the parser,

#pre
?code
============ Some charms
?
#

makes,

?.result
<h12>Some charms<\h12>
?

=== Bracket marks
Some marks form brackets.

In the HTML parser, here are the marks and their defaults,

??
    '#' -> "section",
    '+' -> "ul",
    '-' -> "li",
    '?' -> "pre"
?

TML needs to know a open and a close for bracket marks. Open marks have attributes,
close marks have whitespace,
 
e.g.

#pre
?code
#.georgian
Some text
#
?
#


makes,

?.result
<section class="georgian"><p>Some text<\p><\section>
?

Seems a bit painful though, always putting some attribute or other to identify the open mark? But TML allows a compression, if a neutral block is all that is needed. For the opening mark, repeat the control,

#pre
?code
##
Some text
#
?
#

makes,

?.result
<section><p>Some text<\p><\section>
?

``What", though, you say, ``no <div>?" Override any of the block controls with a new tagname,

 #pre
?code
#div
Some text
#
?
#

makes,

?.result
<div><p>Some text<\p><\div>
?

You got your <div>.

==== Lists
To TML, lists are a bracket mark. With some paragraphs or other blocks inside them. Use paragraphs for list items,

 #pre
?code
++
@ item1
@ item2
+
?
#

makes,

?.result
<ul><li>item1<\li><li>item2<\li><\ul>
?

use the block list item for items grouping other text,

#pre
?code
++
-- item1
Some text
-
-- item2
Some text
-
+
?
#

makes,

?.result
<ul><li><p>item1<\p><p>Some text<\p><\li><li><p>item2<\p><p>Some text<\p><\li><\ul>
?

=== Self-closing marks
There's only one self-closing HTML block of much interest (and that is not of much interest). In the parser, it is defined as,

#pre
?code
_.dashed
?
#

makes,

?.result
<hr class="dashed"/>
?



== Inline level
Inline marks work anyplace inside a paragraph (even at the start and end).

=== Bracket marks
Two marks form the only bracket mark available inline.

In the HTML parser, open,

??
    '[' defauling to "span"
?

and close,

??
']'
?

Open marks can have attributes


#pre
?code
bell [i.stress not] cup
?
#

makes,

?.result
<p>bell <i class="stress">not<\i> cup<\p>
?



==== Links
Ah, yes, links, HTML, the web. TML has no special aprovision for links. But they are not so bad. Override the inline bracket and add the attributes,

#pre
?code
Go to [a.external[go now!]{otherwhere.com} the other side] 
?
#

makes,

?.result
<p>Go to <a class="external" title="go now!" href="otherwhere.com">the other side<\a><\p>
?

Note that links, in this HTML parser, are defined as an inline item (as WC3 defines), and so, if placed at block-level, will get paragraphed.


=== Self-closing marks
There's only one self-closing inline HTML block of much interest. It is of a lot of interest. In the parser, it is defined as,


#pre
?code
*.medium[image of ceramic tiles]{blue-tile.png}
?
#

makes,

?.result
<p><img class="medium" alt="image of ceramic tiles" src="blue-tile.png"/><\p>
?

Note that, as an inline, the image is automatically paragraphed.

(splat = image. opinions, opinions)




////////////////////////////////////////////////////////////////
== Some oddities from the rules
Inline brackets will leave a space at the end of content, if space is placed there (for non-caching parsers, too much trouble to clean up)

Block bracket close must have a whitespace after, so must all self-closing, but not inline brackets.

A few characters are ilegalin literals. Since lteral scanning walks past the usual whitespace approach of TML, these will need testing for. In block lierals, EOF is illegal. In inline literals, EOF and newline are illegal. The test may be implicit -- some scanners, for example, a PEG parser, may incude EOF tests in the code.

If a TML parser finds an illegal character during literal parsing, it must cease the literal parsing immediately. For error correction, normal parsing continued. Method of error correction is not defined --- a TML parser may reject the whole block, write an error, resume normal parsing, outpt or not output the incomplete block. Error correcting method is not defined so differentt parsing strategies and code can be allowed.  

All attributes are followed by a non-outputting space skip. This is not the human way of reading the input, but may be of use to know if implementing a TML parser.

All block-level attribute parses are also followed by a non-significant paragraph, except the literal block, which is followed by a non-significant literal paragraph

== Algorithm
TML is a tool driven by an algorithm, not ``an answer to the question of markup". Here we make that plain by telling you the algorithm, so if you want, you can figure out how it works and what will happen in any given situation.

== Ramifications of spacing and printing

block controls can be followed by newline or space, makes no difference to TML as all whitespace is removed,
## here
#

##
here
#

##      here
#

results in the same markup.

Inline controls can have the space about them adjusted by one space (more spaces are compressed),

one [ two] three
one[ two]three
one[ two         ] three

The inner spaces make no difference to SGML type markups, such as HTML and XML, which specify ignoring these inner spaceas.
They are simply a result of the TML algorithm 
(removing the trailing space involves a nasty long backtrack algorithm)

That the outer spaces can be changed is very, very useful.





== Escaping

TML has no escapes. What for?

Ok, silly question. Escapes primarily, in a markup language,
allow the markup to contain characters which would usually trigger actions.


Secondly, they allow temporary commenting.

=== avoiding character triggering
First, recall that TML is primarily for text maarkup.

TML uses the simple policy of
 asking the user to avoid using the control characters at all.

TML only has three chars which cause actions (excepting
very strange block-level character groups suxh as "\n-"). These are the inline
brackets (open and close), and inline selfclose. These are not
difficult to avoid in text. Some TML implemented parsers
will allow you to define them, so the characters can be avoided on special occasions.

TML takes this attitude because it is a tool. First, it means that TML
will interfere less (TML parsing can be done some way down a rendering
 pipeline whereas many similar parsers demand to go first).

Second, escape code is complex, involves look ahead or behind, and is slow.
Implementing escapes seems not worth the effort.

=== Temporary commenting
Blocks cease to act if they are not left most positioned.
Indent one space, and they will cease to act.

Inlines are a little more difficult to kill. Still,
there are only three characters. kill the opening character of brackets
and the brackets will cease to act, though the code will throw 
warnings due to unopened close brackets.

 
== TML - two kinds of markup


TML allows one bracketed code pair, and one standalone code, to be used in text (inline level).
For the HTML parser, the bracket codes are '[' and ']', and the standalone inline code
is '*'.

== TML - six types of markup
Block level markup allows two separate kinds of block definition. The first uses
(left paced) bracketing marks which surround the text. The second is called paragraph substitute, which uses an opening
(left-placed) mark, but is closed when a newline is found.

The third kind of markup are the brackets allowed when inline, and the fourth is the single code allowed when inline.


== Attributes
Attributes are chained, in any order, after an opening bracket or self-closing mark,

tagName#id.class[text]{url}

The text attribute is not the text for markup, but supplementary texts attached to a tag.
 For example, on some tags HTML offers alt(ernate text) and title attributes.

Attributes must be supplied in the order given, but can be empty if unused or unusable,

tagName{url}

== Tag name aliases
Tagnames can be aliased. Alises work on block and inline bracket marks.

For example, using the HTML parser, block-level "bq" -> "blockquote" i.e.

#bq truth, covered in security \n#
> <blockquote><p>truth, covered in security<\p><\blockquote>

...and inline-level "italic" -> "i" i.e.

bell [italic not] cup
<i>not<\i>



== Markup Control defaults
The name of TML markup controls can be defined by attributes. If the attributes are not present
then the tag name will default.

The most interesting default is the block-level bracketted. Since TML defines that TML must be able
to recognise an opeing tag (for example, it will not count open close), the opening tag is a repetition
of the control. i.e.

##
text
#

defines an opening tag. text, then a closing tag. The block could also be defined this way,
using an explicit tagname,

#section
text
#

== The literals
=== block
One block-level bracket tag can be defined as literal. In HTML, this is the char '?'.
So,

??
To be
  ...or not to be?
That
    [That!]
  is the question.
?

Will pass the inner text through. The HTML parser will produce,

<pre>
To be
  ...or not to be?
That
    [That!]
  is the question.
</pre>

Whitespace is handled consistently with other TML codes. 
So the space deliniating the end of the open mark is not regarded as significant text.
All other whitespace is intended.

?? play
?

> <pre>play<\pre>

??
play
?

> <pre>
play<\pre>

=== inline
One inline tagname will also introduce unparsed inline content. In HTMLL this tagname is again a single '?'.
Nothing in the inline brackets is parsed or altered,

p("bell [?   not\\*#|[clusp   ] cup")

> <p>bell not\*#|[clusp cup<\p>


Make a standard HTML code layout by overriding block defaults,

p("#pre\n?code       var prevChar = currentChar\n       var closing = false\n     forward(until)\n?\n#")

> <pre><code>       var prevChar = currentChar
       var closing = false
     forward(until)<\code><\pre>
     
     
=== self closing markup
TML allows self-closing tags (in HTML, 'void' or 'self-closing tags')
Only one mark is allowed for each of these markup types. Each mark can be defaulted.

Two types exist, a paragraph (substitute) mark, and an inline mark.

In HTML parser, the paragraph self-close defaults to hr,

_.dashed

> <hr class="dashed"/>

The inline self-close defaults to img,

*[image of dolphin]{dolphin.mars}"

> <p><img alt="image of dolphin" src="dolphin.mars"/><\p>


=== auto paragraphing
TML brackets paragraphs with a paragraph markup. This is automatic.
Some parsers may choose to use this ability, some may not.

Note that imline level items are paragraphed 
(such as self-closing inline level markup).




== That's it
TML lacks facilities which users would like. In the words of Ruby, it is not groovy. In the words of Java, it is not professional.
However, it is robust with no complexity. And if extensions like complex image handling are not required
it is good at structuring text.
