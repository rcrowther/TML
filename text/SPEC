= TML Parser Spec
TML is a lightweight markup tool, designed to turn relatively human-readable markup into (a simple subset of) heavyweight markup.


== Generalities

=== TML as typographical
TML syntax is mainly aimed at generating typographical markup.

TML syntax is based round bracketing, not indenting.

~ Rationale
: Bracketing is prone to errors of imbalance. However, it is natural for humans, and mimics the conventions of print typography.

=== TML as a tool
TML is written as a tool. It is formed round the parser, not the end result. This distinguishes it from other Lightweight Markup Languages. 

~ Rationale
: For some markups, TML can be inelegant in use. It is not unobtrusive. However, TML gains the advantages of being easy to comprehend, learn and remember. The implemented parsers are generous with error reports, and at recovering data from malformed input.


==== Explicit markup protection by filtering
A common problem in markup is the need to filter, or protect, areas against parsing. Such areas may include embedded mathematical notation, or computer code.

TML is a tool, so the attitude of the parser should be to ignore such problems. Beyond the TML definition of literals, a TML parser should include no markup protection code. 

If necessary, separate tools may be provided to establish a pipeline. These are encouraged --- e.g. a filter to duck TML literals.
 

== Text format
Input and output is text.

=== Unicode
Unicode may be implemented. Unicode is encouraged, but not required.

=== Space and newlines
Spaces are true spaces (Latin/Unicode SPACE #32).

Newlines are line feed (Latin/Unicode LF #10).

~ Rationale
: line endings can be difficult to implement in parsers, and most intended source and target programs of TML can handle a simple LF. Also, support programs such as GNU ``tr'' may be used for translation.

=== EOF
If a parser needs EOF (End Of File), this is undefined, and regarded as implementation-dependant. However (Latin/Unicode ETX #3) is appropriate.

== I/O

=== I/O type
The type; stream, file, etc. is not defined.

It is worth saying that TML can be parsed as single chars, with no lookabout at all. So TML streaming parsers can be built. However, this spec makes no request for any I/O form.

=== Extended input recognition
The base definition of TML does not cover many implementations of space and line ends.

TML implementations may add, or notate as, a "Universal Support" method. This should admit all Unicode newlines --- which include carriage return (CR), CR + LF and other. It should also convert/handle the full range of Unicode whitespace (which includes tabs, etc.) The method of handling can be in the parsing code itself, or in a pre-scanning conversion.

~ Rationale
: It is more important that a user knows what a parser can or cannot do, as opposed to the parser erratically handling many cases.

=== Output options
Output options may be provided. The first provided option should allow for the CR + LF line ending. 

=== Output
TML output is a single line of text interspaced by tags defined by the markup.
If pretty-printing is required, the output must be run through pretty-printing
formatting code.



== Parsing generalities
Before the rest of this spec, some basics of the parsing.

=== Paragraphs
All non-TML text occurs within paragraphs. Paragraphs are finished with a newline.

=== Whitespace parsing
Excepting text in literal blocks, all space in paragraphs, single or multiple, is replaced by a single space. 

At block level, between markup, all whitespace, single or multiple, newline or space, is removed. 

=== Output
As a result of the above, TML output is a single line of text interspaced by tags defined by the markup.

If pretty-printing is required, the output must be run through pretty-printing
formatting code.


=== Character Escaping
TML has no character escape.

~ Rationale
: Escapes primarily, in a markup language, allow marked text to contain characters which would usually trigger actions. Code for implementing escapes is complex in reasoning and slow. TML has few and unusual marks, and these can often be re-defined.


== Controls
TML works by using one-character/codepoint controls embedded into a text document.
For the purpose of this spec document, marks as realised as a control are named `chars', but may be Unicode codepoints.

=== Control Char definition
?codeblock
BlockParagraphMark = AnyOf('?', ...)
BlockBracketMark = AnyOf('?', ...)
BlockLiteralMark = '?'
BlockSelfClosingMark = '?'

InlineBracketOpenMark = '?'
InlineBracketCloseMark = '?'
?

Controls are initialized by defined chars. The chars can be any char, either defined in the parser or open to the user. All chars must be different.


=== Control Levels
==== Block
?codeblock
SideSignificant = NewLine ~ SkipSpace
?

Block-level control chars ar only active when  only  when preceeded by a newline, or
a newline followed by space.

==== Inline
Inline control chars are active anywhere in the document.

NB: If an inline control appears at block level, it will be assumed to start a paragraph.


==== Attributes
?codeblock
AttributeValue = zeroOrMore(Letter)
Attributes = (
~ Option('.'  ~ AttributeValue)
~ Option('[' ~ zeroOrMore(Any) ~ (']' | NewLine))
~ Option('{'  ~ zeroOrMore(Any) ~ ('}' | NewLine))
) ~ Whitespace
?

Bracket opening and selfclosing marks can be followed by an attributes string. 

?codeblock
. class attribute
 text attribute
{} URL attribute
?

Attributes must be in this order. All attributes are optional. Parsers may allow attributes to be repeated. For repeated attributes, the set may be rejected, in part or whole, but only the first accepted instances are used. 

Whitespace, either newline or space. finishes the attribute set.\The bracketed options allow spacing in the contents. Other attribute values (''id' and ''class') must have not any space within them.

Attributes supplied with zero contents may render as an attribute with no content, or not at all, depending on the target markup.

The two bracketed attributes, text attribute and URL attribute, can,  exceptionally, be closed with a newline. See [a Inline close by newline]

~ Note 
: a newline will terminate the bracketed options. See ''Inline close by newline'.


===== Note for implementations
None of these characters can be used for other block-level codes. 


There is ambiguity between the control mark and the opening attribute mark. If ``#'' is an block-level open mark then, is this, 

?codeblock
  ##
?

a defaulting block control or a block with an empty ``id'' attribute?

This can be made to work, but the fix produces inconsistent markup, and must not be implemented.

TML does not say it is inline until it is in a paragraph, so the attribute codes can be used inline.


== Block-level marks
Block level marks are all side-significant.

=== Bracketted blocks
?codeblock
BlockBracketed = BlockBracketMark ~ Attributes ~ SpaceDelimit
~ Paragraph ~ SideSignificant ~ BlockBracketMark
 ~ SpaceDelimit ~ Paragraph
?

Bracketted blocks open and close with BlockBracketMark.

TML uses the same control for open and close. However, TML can distinguish between open and close. An block open mark will always be followed by some form of text (attributes), whereas a close will be followed by whitespace.

=== The repeated control convention (for opening marks)
All block marks are provided with a default tagname (for the resulting markup). If a mark is repeated, then it should be given the default tagname.

~ Rationale
: This repetition is unobtrusive, easy to type, and means opening tags can always be distinguished from close tags. 


=== Paragraphs
TML detects non-whitepace and initiates a paragraph output of text (some markup parsers are more efficient so dumb-pass anything which is not markup, but not TML).


Within a paragraph, inline marks will be processed, and multiple spaces compressed to one.

A paragraph ends on a newline (TML is typography-based, so this is fine. The implementation need not be newline based, and this will prove cumbersome if you ever need to markup the final chapter of ``Portrait of the Artist as a Young man", but that's a TML compromise).



=== The literal block
The literal block is opened by a special mark. The literal block is closed by the same mark. The marks are handled as other block bracket marks i.e. the first mark is followed by attributes or a default mark repetition. 
 
In this state, the parser will not process the block content. The bulk of the following text, including spaces and whitespace, is printed directly to the output, until a closing mark.

In line with other opening marks, space following the opening mark is consumed.

The spacing preceding a literal block close is problem for TML. Usually TML can tell what to do with any character depending on the parser's state. But for a literal end mark, this can be expensive. The most consistent treatment is to remove the side significant mark preceding a close mark i.e. the newline followed by the space. But this can only be identified if all space in the literal is cached, pending writing to the output (so the last space can be disposed, if it proves to preced a close mark).
 
Thus, TML defines two possibilities for closing block literal space. The first preferred method is to remove the definition of  of the significant space. Parsers based in a parsing program can do this naturally. The alternative algorithm is to remove the character preceding the close mark, which may be a newline, or a space after a newline. This provides an easy solution for parsers which step  through input, requiring a cache of only one character. This second solution can also be implemented, if required and with a little extra complexity, with no lookback.
 
~ Rationale
: A special mark is preferred to a more semanticly meaningful tagname, because the search for the literal block end would fail on any legitimate block end, whereas a special mark positively identifies the literal close.



== Inline-level marks
Inline marks are active within paragraphs (excepting the contents of a block-level literal).

=== Bracketted inlines

=== Self-closing inlines

=== Literal inline
The literal inline is initiated by a special tagname. The literal inline is closed by an inline close or, exceptionally, a newline. For the newline close, see [a Inline close by newline]. In other respects, the marks are handled as other inline bracket marks i.e. the first mark is followed by attributes. 

In line with other opening marks, space following the opening mark is consumed.

In this state, the parser will not process the block content. The bulk of the following text, including spaces and whitespace, is printed directly to the output, until a closing mark.

The spacing preceding a literal inline close is problem for TML. For a discussion on this, see the notes for the literal block close. Again, two methods are offered for implementation. First, and preferred, is to remove all space before the close mark. Second, especially for use if the parser does not cache many characters or there is a need for always scanning forward, print all space preceding the close mark (the user can always compress this space themselves). 

~ Rationale
: Though more consistent with the block literal if it were a mark, a special tagname is preferred to a special mark. The special tagname is more semanticly meaningful, and keeps the number of possible inline marks to a minimum.

=== Inline close by newline
In some situations, brackets can be written which are intended as inline, but are followed by newlines.

The situations are the two bracketed attributes, text and URL, and the inline bracket mark. For implementations, there is an important subsection of the inline mark, the bracketed literal mark, which may need to be separately addressed.

TML is a soft parser, that is, it attempts to generate output when possible. So this situation is not defined as an error. The presence of a newline ends the lineline bracket, same as a close mark. The newline used as closure is not consumed.

Parsers which report errors may wish to report a warning to the user, e.g. ``Inline brackets ended by newline. This is possibly an unintended closure.".

An implication of this is, since paragraphs finish on newlines, all inline brackets are auto-closed on paragraph ends --- the same newline will do them all.



== Grammar
A PEG-like grammar for TML

?codeblock
BlockParagraphMark = AnyOf('?', ...)
BlockBracketMark = AnyOf('?', ...)
BlockLiteralMark = '?'
BlockSelfClosingMark = '?'

InlineBracketOpenMark = '?'
InlineBracketCloseMark = (? | NewLine)
InlineSelfClosingMark = '?'

// general
LiteralParagraph = zeroOrMore(Any)

NonNewline = !NewLine

SpaceDelimit = ' '

SkipSpace = zeroOrMore(Space)

// general rules

/** Parses inline, but not any side significant marks.
*
* Ends on newline.
*/
Paragraph = zeroOrMore(NonNewline)
InlineLiteralText = zeroOrMore(NonNewline)
BlockLiteralText = zeroOrMore(Any)

SideSignificant = NewLine ~ SkipSpace

AttributeValue = zeroOrMore(Letter)
AttributeValueWithSpace = zeroOrMore(Letter | ' ')

Attributes =
~ Option('.'  ~ AttributeValue)
~ Option('[' ~ AttributeValueWithSpace ~ (']' | NewLine) )
~ Option('{' ~ AttributeValueWithSpace ~ ('}' | NewLine) )
~ ' ' ~ SkipSpace


// rules

// bracketted inline
InlineBracketed = InlineBracketOpenMark ~ Attributes ~ SpaceDelimit
 ~ Paragraph ~ InlineBracketCloseMark

// self-closing inline
InlineSelfClosing = InlineSelfClosingMark ~ Attributes ~ SpaceDelimit

// bracketted block
BlockBracketed = BlockBracketMark ~ Attributes ~ SpaceDelimit
~ Paragraph ~ SideSignificant ~ BlockBracketMark
 ~ SpaceDelimit ~ Paragraph

// literal bracketted block
BlockLiteral = BlockLiteralMark ~ Attributes ~ SpaceDelimit
 ~ LiteralParagraph ~ SideSignificant ~ BlockLiteralMark
 ~ SpaceDelimit ~ Paragraph

// paragraph block
BlockParagraphOpenMark = BlockParagraphMark ~ Attributes ~ SpaceDelimit
//NB: bear in mind paragraph close is a newline
SideSignificant ~ Paragraph

// self-closing block
BlockSelfClosing = BlockSelfClosingMark ~ Attributes ~ SpaceDelimit
 ~ SpaceDelimit ~ Paragraph

parser =
SideSignificant ~ (
BlockBracketted
| BlockSelfClosing
| BlockParagraphOpenMark
| BlockLiteral
| Paragraph
)
?

