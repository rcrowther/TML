= Spec
TML is a lightweight markup tool, designed to turn relaively human-readable markup into (simple) heavyweight markup.


== Generalities

=== TML as typorgaphical
TML syntax is mainly aimed at generating typographical markup.

TML is based round bracketting, not indenting.

~ Rationale
: Bracketting is prone to errors of imbalance. However, it is natural for humans, and mimics the conventions of print typography.

=== TML as a tool
TML is written as a tool. It is formed round the parser, not the end result. This distingushes it from other Lightweght Markup Languages. 

~ Rationale
: For some markups, TML can be inelegant in use. It is not unobtrusive. However, TML gains the advantages of being easy to comprehend, learn and remember. The implemented parsers are generous with error reports, and at recovering data from malformed input.




== Input format
Input is text. The form, stream, file, is not defined.

=== Unicode
Unicode may be implemented. Unicode is encouraged, but not required.

=== Space and newlines
Spaces are true spaces (Latin/Unicode SPACE #32).

Newlines are line feed (Latin/Unicode LF #10).

~ Rationale
: line endings can be difficult to implement in parsers, and most intended source and target programs of TML can handle a simple LF. Also, support programs such as GNU ``tr'' may be used for translation.

=== EOF
If a parser needs EOF (End Of File), this is undefined, and regarded as implementation-dependant. However (Latin/Unicode ETX #3) is appropriate.

=== Extended input recognition
The base definition of TML does not cover many implementations of space and line ends.

TML implemenations may add, or notate as, a "Universal Support" method. This should admit all Unicode newlines --- which include carriage return (CR), CR + LF and other. It should also convert/handle the full range of Unicode whitespace (which includes tabs, etc.) The method of handling can be in the parsing code itself, or in a pre-scanning conversion.

~ Rationale
: It is more important that a user knows what a parser can or cannot do, as opposed to the parser erratically handling many cases.

=== Output options
Output options may be provided. The first provided option should allow for the CR + LF line ending. 


== Parsing generalities
Before the rest of this spec, some introduction to basics of the parsing.

=== Paragraphs
All non-TML text occours within paragraphs. Paragraphs are finished with a newline.

=== Whitespace parsing
Exepting text in literal blocks, all space in paragraphs, single or multiple, is replaced by a single space. 

At block level, between markup, all whitespace, single or multiple, newline or space, is removed. 

== Output
As a result of the above, TML output is a single line of text interspaced by tags defined by the markup.

If pretty-printing is required, the output must be run through pretty-printing
formatting code.


=== Character Escaping
TML has no character escape.

~ Rationale
: Escapes primarily, in a markup language, allow marked text to contain characters which would usually trigger actions. Code for implementing escapes is complex in reasoning and slow. TML has few and unusual marks, and these can often be re-defined.


== Controls
TML works by using one-character/codepoint controls embedded into a text document.
For the purpose of this spec document, marks as realised as a control are reffereed to as ``chars'', but may be unicode codepoints.

=== Control Char definition
BlockParagraphMark = AnyOf('?', ...)
BlockBracketMark = AnyOf('?', ...)
BlockLiteralMark = '?'
BlockSelfClosingMark = '?'

InlineBracketOpenMark = '?'
InlineBracketCloseMark = '?'

Controls are initialized by defined chars. The chars can be any char, either defined in the parser or open to the user. All chars must be different.


=== Control Levels
==== Block
SideSignificant = NewLine ~ SkipSpace

Block-level control chars ar only active when  only  when preceeded by a newline, or
a newline followed by space.

==== Inline
Inline control chars are active anywhere in the document.

NB: If an inline control appears at block level, it will be assumed to start a paragraph.


==== Attributes
#pre
?code
AttributeValue = zeroOrMore(Letter)
Attributes = (
~ Option('#' ~ AttributeValue)
~ Option('.'  ~ AttributeValue)
~ Option('[' ~ zeroOrMore(Any) ~ (']' | NewLine))
~ Option('{'  ~ zeroOrMore(Any) ~ ('}' | NewLine))
) ~ Whitespace
?
#

Bracket opening and selfclosing marks can be followed by an attributes string. 

# id attribute
. class attribute
[] text attribute
{} URL attribute

All attributes are optional and can be presented in any order.

Whitespace, either newline or space. finishes the attribute set.
The bracketted options allow spacing in the contents. Other attribute values (``id'' and ``class'') must have not any space within them.

Attributes supplied with zero contents may render as an attribute with no content, or not at all, depending on the target markup.

The two bracketted attributes, text attribute and URL attribute, can,  exceptionally, be closed with a newline. See [a Inline close by newline]

~ Note 
: a newline will terminate the bracketted options. See ``Inline close by newline''.


===== Note for implementations
It would seem offhand that none of these characters can be used for other codes, but that is not true. 

TML does not say it is inline until it is in a paragraph, so feel free to use them inline.

There is ambiguity between the control mark and the opening attribute mark. If ``#'' is an block-level open mark, is this, 

#pre
?code ##
?
#

a defaulting block control or a block with an empty ``id'' attibute?

However, this can be made to work, with one proviso. The markup must not print out empty attributes. Consider this parse,

?? (# control)(# tagname)
?

The control knows it is an open, due to the following char. With no tagname it defaults. But the tagname is empty. The result is as expected.


== Block level marks
Block level marks are all side-significant.

=== Bracketted blocks
BlockBracketed = BlockBracketMark ~ Attributes ~ SpaceDelimit
~ Paragraph ~ SideSignificant ~ BlockBracketMark
 ~ SpaceDelimit ~ Paragraph

Bracketted blocks open and close with BlockBracketMark.

TML uses the same control for open and close. However, TML can distinuish between open and close. An block open mark will always be followed by some form of text (attributes), wheras a close will be followed by whitespace.

=== The repeated control convention (for opening marks)
All block marks are provided with a default tagname (for the resulting markup). If a mark is repeated, then it should be given the default tagname.

~ Rationale
: This repetition is unobtrusive, easy to type, and means opening tags can always be disingushed from close tags. 


=== Paragraphs
TML detects non-whitepace and initiates a paragraph output of text (some markup parsers are more efficient so dumb-pass anything which is not markup, but not TML).


Within a paragraph, inline marks will be processed, and multiple spaces compressed to one.

A paragraph ends on a newline (TML is typography-based, so this is fine. The implementation need not be newline based, and this will prove climbersome if you ever need to markup the final chapter of ``Portrait of the Artist as a Yund man", but that's a TML compromise).



=== The literal block
The literal block is initiated by a special mark.
 
In the resulting special state, the parser will not process the block content. The bulk of the following text, including spaces and whitespace, is printed directly to the output, until the closing control.

The literal block handles the marks as other block bracket marks. 

In line with other opening marks, space following the opening mark is consumed.

The spacing preceeding a literal block close is problem for TML. Usually TML can tell what to do with any character depending on the parser's state. But for a literal end mark, this can be expensive. The most consistent treatment is to remove the side significant mark preceeding a close mark i.e. the newline followed by the space. But this can only be identified if all space in the literal is cached, pending writing to the output (so the last space can be disposed, if it proves to preceed a close mark).
 
Thus, TML defines two possibilities for closing block literal space. The first preferred method is to remove the definition of  of the significant space. Parsers based in a parsing program can do this naturally. The alternative algorithm is to remove the character preceeding the close mark, which may be a newline, or a space after a newline. This provides an easy solution for parsers which step  through input, requiring a cache of only one character. This second solution can also be implemented, if required and with a little extra complexity, with no lookback.
 
~ Rationale
: A special mark is preferred to a more semanticly meaningful tagname, because the search for the block end would fail on any legitimate block end, whereas a special mark positivly identifies the literal close.

== Literal inline
The literal inline is initiated by a special tagname.

The literal inline is closed by an inlince close or, exceptionally, a newline. For the newline close, see [a Inline close by newline].

In line with other opening marks, space following the opening mark is consumed.


In the resulting special state, the parser will not process the block content. The bulk of the following text, including spaces and whitespace, is printed directly to the output, until the closing control.

The spacing preceeding a literal inline close is problem for TML. For a discussion on this, see the notes for the literal block close. Again, two methods are offered for implementation. First, and preferred, is to remove all space before the close mark. Second, especially for use if the parser does not cache many characters or there is a need for always scanning forward, print all space preceeding the close mark (the user can always compress this space themselves). 

~ Rationale
: Though more consistent with the block literal if it were a mark, a special tagname is preferred to a special mark. The special tagname is more semanticly meaningful, and keeps the number of possible inline marks to a minimum.

=== Inline close by newline
In some situations, brackets can be written which are intended as inline, but are followed by newlines.

The situations are the two bracketted attributes, text and URL, and the inline bracket mark. For implementations, there is an important subsection of the inline mark, the bracketted literal mark, which may need to be seperately addressed.

TML is a soft parser, that is, it attempts to generate output when possible. So this situation is not defined as an error. The presence of a newline ends the lineline bracket, same as a close mark. The newline used as closure is not consumed.

Parsers which report errors may wish to report a warning to the user, e.g. ``Inline brackets ended by newline. This is possibly an unintended closure.".

An implication of this is, since paragraphs finish on newlines, all inline brackets are auto-closed on paragraph ends --- the same newline will do them all.



=== Grammar
A PEG-like grammar for TML

BlockParagraphMark = AnyOf('?', ...)
BlockBracketMark = AnyOf('?', ...)
BlockLiteralMark = '?'
BlockSelfClosingMark = '?'

InlineBracketOpenMark = '?'
InlineBracketCloseMark = (? | NewLine)
InlineSelfClosingMark = '?'

// general
LiteralParagraph = zeroOrMore(Any)

NonNewline = !NewLine

SpaceDelimit = ' '

SkipSpace = zeroOrMore(Space)

// general rules

/** Parses inline, but not any side significant marks.
*
* Ends on newline.
*/
Paragraph = zeroOrMore(NonNewline)
InlineLiteralText = zeroOrMore(NonNewline)
BlockLiteralText = zeroOrMore(Any)

SideSignificant = NewLine ~ SkipSpace

AttributeValue = zeroOrMore(Letter)
AttributeValueWithSpace = zeroOrMore(Letter | ' ')

Attributes = 
~ Option('#' ~ AttributeValue)
~ Option('.'  ~ AttributeValue)
~ Option('[' ~ AttributeValueWithSpace ~ (']' | NewLine) )
~ Option('{' ~ AttributeValueWithSpace ~ ('}' | NewLine) )
~ ' ' ~ SkipSpace


// rules

// bracketted inline
InlineBracketed = InlineBracketOpenMark ~ Attributes ~ SpaceDelimit
 ~ Paragraph ~ InlineBracketCloseMark

// self-closing inline
InlineSelfClosing = InlineSelfClosingMark ~ Attributes ~ SpaceDelimit

// bracketted block
BlockBracketed = BlockBracketMark ~ Attributes ~ SpaceDelimit
~ Paragraph ~ SideSignificant ~ BlockBracketMark
 ~ SpaceDelimit ~ Paragraph

// literal bracketted block
BlockLiteral = BlockLiteralMark ~ Attributes ~ SpaceDelimit
 ~ LiteralParagraph ~ SideSignificant ~ BlockLiteralMark
 ~ SpaceDelimit ~ Paragraph

// paragraph block
BlockParagraphOpenMark = BlockParagraphMark ~ Attributes ~ SpaceDelimit
//NB: bear in mind paragraph close is a newline
SideSignificant ~ Paragraph

// self-closing block
BlockSelfClosing = BlockSelfClosingMark ~ Attributes ~ SpaceDelimit
 ~ SpaceDelimit ~ Paragraph

parser =
SideSignificant ~ (
BlockBracketted
| BlockSelfClosing
| BlockParagraphOpenMark
| BlockLiteral
| Paragraph
)


